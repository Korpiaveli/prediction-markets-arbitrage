/**
 * Email Provider
 *
 * Sends notifications via email using SMTP or SendGrid.
 */

import * as nodemailer from 'nodemailer';
import {
  NotificationPayload,
  NotificationResult,
  ChannelType,
  EmailProviderConfig
} from '../types';
import { BaseProvider } from './BaseProvider';

export class EmailProvider extends BaseProvider {
  readonly channel: ChannelType = 'email';
  protected emailConfig: EmailProviderConfig;
  private transporter: nodemailer.Transporter | null = null;

  constructor(config: EmailProviderConfig) {
    super(config);
    this.emailConfig = config;

    if (config.enabled && config.type === 'smtp' && config.smtp) {
      this.transporter = nodemailer.createTransport({
        host: config.smtp.host,
        port: config.smtp.port,
        secure: config.smtp.secure ?? config.smtp.port === 465,
        auth: {
          user: config.smtp.auth.user,
          pass: config.smtp.auth.pass
        }
      });
    }
  }

  async send(payload: NotificationPayload): Promise<NotificationResult> {
    if (!this.isEnabled()) {
      return this.createErrorResult('Email provider is disabled');
    }

    if (!this.transporter) {
      return this.createErrorResult('Email transporter not configured');
    }

    try {
      const html = this.formatHtml(payload);
      const text = this.formatPlainText(payload);

      const info = await this.transporter.sendMail({
        from: this.emailConfig.from,
        to: this.emailConfig.to.join(', '),
        subject: this.formatSubject(payload),
        text,
        html
      });

      return this.createSuccessResult(info.messageId);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return this.createErrorResult(`Failed to send email: ${errorMessage}`);
    }
  }

  private formatSubject(payload: NotificationPayload): string {
    const priorityPrefix = payload.priority === 'critical' ? '[CRITICAL] ' :
                          payload.priority === 'high' ? '[URGENT] ' : '';
    return `${priorityPrefix}${this.getPriorityEmoji(payload)} ${payload.title}`;
  }

  private formatPlainText(payload: NotificationPayload): string {
    let text = `${payload.title}\n${'='.repeat(50)}\n\n`;
    text += `Priority: ${payload.priority.toUpperCase()}\n`;
    text += `Type: ${payload.type}\n`;
    text += `Time: ${payload.timestamp.toISOString()}\n\n`;
    text += payload.body;

    if (payload.data && Object.keys(payload.data).length > 0) {
      text += '\n\n--- Details ---\n';
      for (const [key, value] of Object.entries(payload.data)) {
        text += `${key}: ${JSON.stringify(value)}\n`;
      }
    }

    return text;
  }

  private formatHtml(payload: NotificationPayload): string {
    const priorityColor = payload.priority === 'critical' ? '#dc3545' :
                         payload.priority === 'high' ? '#fd7e14' :
                         payload.priority === 'medium' ? '#ffc107' : '#28a745';

    return `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { background: ${priorityColor}; color: white; padding: 15px; border-radius: 5px 5px 0 0; }
    .content { border: 1px solid #ddd; border-top: none; padding: 20px; border-radius: 0 0 5px 5px; }
    .meta { color: #666; font-size: 0.9em; margin-bottom: 15px; }
    .priority { display: inline-block; padding: 3px 8px; border-radius: 3px; background: ${priorityColor}; color: white; font-size: 0.8em; }
    .data-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
    .data-table th, .data-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    .data-table th { background: #f5f5f5; }
    .footer { margin-top: 20px; padding-top: 15px; border-top: 1px solid #ddd; font-size: 0.85em; color: #666; }
  </style>
</head>
<body>
  <div class="header">
    <h2 style="margin: 0;">${this.getPriorityEmoji(payload)} ${this.escapeHtml(payload.title)}</h2>
  </div>
  <div class="content">
    <div class="meta">
      <span class="priority">${payload.priority.toUpperCase()}</span>
      &nbsp;|&nbsp; ${payload.type}
      &nbsp;|&nbsp; ${payload.timestamp.toLocaleString()}
    </div>
    <div class="body">
      ${this.escapeHtml(payload.body).replace(/\n/g, '<br>')}
    </div>
    ${this.formatDataTable(payload.data)}
    <div class="footer">
      Notification ID: ${payload.id}<br>
      Generated by Arbitrage Scanner
    </div>
  </div>
</body>
</html>`;
  }

  private formatDataTable(data?: Record<string, unknown>): string {
    if (!data || Object.keys(data).length === 0) return '';

    let html = '<table class="data-table"><tr><th>Field</th><th>Value</th></tr>';
    for (const [key, value] of Object.entries(data)) {
      html += `<tr><td><strong>${this.escapeHtml(key)}</strong></td><td>${this.escapeHtml(String(value))}</td></tr>`;
    }
    html += '</table>';
    return html;
  }

  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  async verify(): Promise<boolean> {
    if (!this.transporter) return false;
    try {
      await this.transporter.verify();
      return true;
    } catch {
      return false;
    }
  }
}
